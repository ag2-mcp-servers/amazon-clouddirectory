# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T09:58:07+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel, conint, constr


class AccessDeniedException(RootModel[Any]):
    root: Any


class AddFacetToObjectResponse(BaseModel):
    pass


class Arn(RootModel[str]):
    root: str


class Arns(RootModel[List[Arn]]):
    root: List[Arn]


class AttachPolicyResponse(BaseModel):
    pass


class AttributeName(
    RootModel[constr(pattern=r'^[a-zA-Z0-9._:-]*$', min_length=1, max_length=230)]
):
    root: constr(pattern=r'^[a-zA-Z0-9._:-]*$', min_length=1, max_length=230)


class AttributeNameList(RootModel[List[AttributeName]]):
    root: List[AttributeName]


class BatchAddFacetToObjectResponse(BaseModel):
    pass


class BatchAttachPolicyResponse(BaseModel):
    pass


class BatchDeleteObjectResponse(BaseModel):
    pass


class BatchDetachPolicyResponse(BaseModel):
    pass


class BatchDetachTypedLinkResponse(BaseModel):
    pass


class BatchReadExceptionType(Enum):
    ValidationException = 'ValidationException'
    InvalidArnException = 'InvalidArnException'
    ResourceNotFoundException = 'ResourceNotFoundException'
    InvalidNextTokenException = 'InvalidNextTokenException'
    AccessDeniedException = 'AccessDeniedException'
    NotNodeException = 'NotNodeException'
    FacetValidationException = 'FacetValidationException'
    CannotListParentOfRootException = 'CannotListParentOfRootException'
    NotIndexException = 'NotIndexException'
    NotPolicyException = 'NotPolicyException'
    DirectoryNotEnabledException = 'DirectoryNotEnabledException'
    LimitExceededException = 'LimitExceededException'
    InternalServiceException = 'InternalServiceException'


class BatchReferenceName(RootModel[str]):
    root: str


class BatchRemoveFacetFromObjectResponse(BaseModel):
    pass


class BatchUpdateLinkAttributesResponse(BaseModel):
    pass


class BatchWriteException(RootModel[Any]):
    root: Any


class BinaryAttributeValue(RootModel[str]):
    root: str


class Bool(RootModel[bool]):
    root: bool


class BooleanAttributeValue(RootModel[bool]):
    root: bool


class CannotListParentOfRootException(RootModel[Any]):
    root: Any


class ConsistencyLevel(Enum):
    SERIALIZABLE = 'SERIALIZABLE'
    EVENTUAL = 'EVENTUAL'


class CreateFacetResponse(BaseModel):
    pass


class CreateSchemaResponse(BaseModel):
    SchemaArn: Optional[Arn] = None


class CreateTypedLinkFacetResponse(BaseModel):
    pass


class Date(RootModel[datetime]):
    root: datetime


class DatetimeAttributeValue(RootModel[datetime]):
    root: datetime


class DeleteDirectoryRequest(BaseModel):
    pass


class DeleteDirectoryResponse(BaseModel):
    DirectoryArn: Arn


class DeleteFacetResponse(BaseModel):
    pass


class DeleteObjectResponse(BaseModel):
    pass


class DeleteSchemaRequest(BaseModel):
    pass


class DeleteSchemaResponse(BaseModel):
    SchemaArn: Optional[Arn] = None


class DeleteTypedLinkFacetResponse(BaseModel):
    pass


class DetachPolicyResponse(BaseModel):
    pass


class DirectoryAlreadyExistsException(RootModel[Any]):
    root: Any


class DirectoryArn(RootModel[str]):
    root: str


class DirectoryDeletedException(RootModel[Any]):
    root: Any


class DirectoryName(
    RootModel[constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=64)]
):
    root: constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=64)


class DirectoryNotDisabledException(RootModel[Any]):
    root: Any


class DirectoryNotEnabledException(RootModel[Any]):
    root: Any


class DirectoryState(Enum):
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'
    DELETED = 'DELETED'


class DisableDirectoryRequest(BaseModel):
    pass


class DisableDirectoryResponse(BaseModel):
    DirectoryArn: Arn


class EnableDirectoryRequest(BaseModel):
    pass


class EnableDirectoryResponse(BaseModel):
    DirectoryArn: Arn


class ExceptionMessage(RootModel[str]):
    root: str


class FacetAlreadyExistsException(RootModel[Any]):
    root: Any


class FacetAttributeType(Enum):
    STRING = 'STRING'
    BINARY = 'BINARY'
    BOOLEAN = 'BOOLEAN'
    NUMBER = 'NUMBER'
    DATETIME = 'DATETIME'
    VARIANT = 'VARIANT'


class FacetInUseException(RootModel[Any]):
    root: Any


class FacetName(
    RootModel[constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=64)]
):
    root: constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=64)


class FacetNameList(RootModel[List[FacetName]]):
    root: List[FacetName]


class FacetNotFoundException(RootModel[Any]):
    root: Any


class FacetStyle(Enum):
    STATIC = 'STATIC'
    DYNAMIC = 'DYNAMIC'


class FacetValidationException(RootModel[Any]):
    root: Any


class GetAppliedSchemaVersionRequest(BaseModel):
    SchemaArn: Arn


class GetAppliedSchemaVersionResponse(BaseModel):
    AppliedSchemaArn: Optional[Arn] = None


class GetDirectoryRequest(BaseModel):
    pass


class GetFacetRequest(BaseModel):
    Name: FacetName


class GetSchemaAsJsonRequest(BaseModel):
    pass


class GetTypedLinkFacetInformationResponse(BaseModel):
    IdentityAttributeOrder: Optional[AttributeNameList] = None


class IncompatibleSchemaException(RootModel[Any]):
    root: Any


class IndexedAttributeMissingException(RootModel[Any]):
    root: Any


class InternalServiceException(RootModel[Any]):
    root: Any


class InvalidArnException(RootModel[Any]):
    root: Any


class InvalidAttachmentException(RootModel[Any]):
    root: Any


class InvalidFacetUpdateException(RootModel[Any]):
    root: Any


class InvalidNextTokenException(RootModel[Any]):
    root: Any


class InvalidRuleException(RootModel[Any]):
    root: Any


class InvalidSchemaDocException(RootModel[Any]):
    root: Any


class InvalidTaggingRequestException(RootModel[Any]):
    root: Any


class LimitExceededException(RootModel[Any]):
    root: Any


class LinkName(
    RootModel[
        constr(pattern=r'[^\/\[\]\(\):\{\}#@!?\s\\;]+', min_length=1, max_length=64)
    ]
):
    root: constr(pattern=r'[^\/\[\]\(\):\{\}#@!?\s\\;]+', min_length=1, max_length=64)


class LinkNameAlreadyInUseException(RootModel[Any]):
    root: Any


class NextToken(RootModel[str]):
    root: str


class NotIndexException(RootModel[Any]):
    root: Any


class NotNodeException(RootModel[Any]):
    root: Any


class NotPolicyException(RootModel[Any]):
    root: Any


class NumberAttributeValue(RootModel[str]):
    root: str


class NumberResults(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class ObjectAlreadyDetachedException(RootModel[Any]):
    root: Any


class ObjectIdentifier(RootModel[str]):
    root: str


class ObjectIdentifierAndLinkNameTuple(BaseModel):
    LinkName_1: Optional[LinkName] = Field(None, alias='LinkName')
    ObjectIdentifier_1: Optional[ObjectIdentifier] = Field(
        None, alias='ObjectIdentifier'
    )


class ObjectIdentifierList(RootModel[List[ObjectIdentifier]]):
    root: List[ObjectIdentifier]


class ObjectIdentifierToLinkNameMap(RootModel[Optional[Dict[str, LinkName]]]):
    root: Optional[Dict[str, LinkName]] = None


class ObjectNotDetachedException(RootModel[Any]):
    root: Any


class ObjectType(Enum):
    NODE = 'NODE'
    LEAF_NODE = 'LEAF_NODE'
    POLICY = 'POLICY'
    INDEX = 'INDEX'


class PathString(RootModel[str]):
    root: str


class PathToObjectIdentifiers(BaseModel):
    ObjectIdentifiers: Optional[ObjectIdentifierList] = None
    Path: Optional[PathString] = None


class PathToObjectIdentifiersList(RootModel[List[PathToObjectIdentifiers]]):
    root: List[PathToObjectIdentifiers]


class PolicyType(RootModel[str]):
    root: str


class PublishSchemaResponse(BaseModel):
    PublishedSchemaArn: Optional[Arn] = None


class PutSchemaFromJsonResponse(BaseModel):
    Arn_1: Optional[Arn] = Field(None, alias='Arn')


class RangeMode(Enum):
    FIRST = 'FIRST'
    LAST = 'LAST'
    LAST_BEFORE_MISSING_VALUES = 'LAST_BEFORE_MISSING_VALUES'
    INCLUSIVE = 'INCLUSIVE'
    EXCLUSIVE = 'EXCLUSIVE'


class RemoveFacetFromObjectResponse(BaseModel):
    pass


class RequiredAttributeBehavior(Enum):
    REQUIRED_ALWAYS = 'REQUIRED_ALWAYS'
    NOT_REQUIRED = 'NOT_REQUIRED'


class ResourceNotFoundException(RootModel[Any]):
    root: Any


class RetryableConflictException(RootModel[Any]):
    root: Any


class RuleKey(
    RootModel[constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=64)]
):
    root: constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=64)


class RuleParameterKey(RootModel[str]):
    root: str


class RuleParameterValue(RootModel[str]):
    root: str


class RuleType(Enum):
    BINARY_LENGTH = 'BINARY_LENGTH'
    NUMBER_COMPARISON = 'NUMBER_COMPARISON'
    STRING_FROM_SET = 'STRING_FROM_SET'
    STRING_LENGTH = 'STRING_LENGTH'


class SchemaAlreadyExistsException(RootModel[Any]):
    root: Any


class SchemaAlreadyPublishedException(RootModel[Any]):
    root: Any


class SchemaFacet(BaseModel):
    FacetName_1: Optional[FacetName] = Field(None, alias='FacetName')
    SchemaArn: Optional[Arn] = None


class SchemaFacetList(RootModel[List[SchemaFacet]]):
    root: List[SchemaFacet]


class SchemaJsonDocument(RootModel[str]):
    root: str


class SchemaName(
    RootModel[constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=32)]
):
    root: constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=32)


class SelectorObjectReference(RootModel[str]):
    root: str


class StillContainsLinksException(RootModel[Any]):
    root: Any


class StringAttributeValue(RootModel[str]):
    root: str


class TagKey(RootModel[str]):
    root: str


class TagKeyList(RootModel[List[TagKey]]):
    root: List[TagKey]


class TagResourceResponse(BaseModel):
    pass


class TagValue(RootModel[str]):
    root: str


class TagsNumberResults(RootModel[conint(ge=50)]):
    root: conint(ge=50)


class TypedAttributeValue(BaseModel):
    BinaryValue: Optional[BinaryAttributeValue] = None
    BooleanValue: Optional[BooleanAttributeValue] = None
    DatetimeValue: Optional[DatetimeAttributeValue] = None
    NumberValue: Optional[NumberAttributeValue] = None
    StringValue: Optional[StringAttributeValue] = None


class TypedAttributeValueRange(BaseModel):
    EndMode: RangeMode
    EndValue: Optional[TypedAttributeValue] = None
    StartMode: RangeMode
    StartValue: Optional[TypedAttributeValue] = None


class TypedLinkAttributeRange(BaseModel):
    AttributeName_1: Optional[AttributeName] = Field(None, alias='AttributeName')
    Range: TypedAttributeValueRange


class TypedLinkAttributeRangeList(RootModel[List[TypedLinkAttributeRange]]):
    root: List[TypedLinkAttributeRange]


class TypedLinkName(RootModel[constr(pattern=r'^[a-zA-Z0-9._-]*$')]):
    root: constr(pattern=r'^[a-zA-Z0-9._-]*$')


class TypedLinkNameList(RootModel[List[TypedLinkName]]):
    root: List[TypedLinkName]


class TypedLinkSchemaAndFacetName(BaseModel):
    SchemaArn: Arn
    TypedLinkName_1: TypedLinkName = Field(..., alias='TypedLinkName')


class UnsupportedIndexTypeException(RootModel[Any]):
    root: Any


class UntagResourceRequest(BaseModel):
    ResourceArn: Arn
    TagKeys: TagKeyList


class UntagResourceResponse(BaseModel):
    pass


class UpdateActionType(Enum):
    CREATE_OR_UPDATE = 'CREATE_OR_UPDATE'
    DELETE = 'DELETE'


class UpdateFacetResponse(BaseModel):
    pass


class UpdateLinkAttributesResponse(BaseModel):
    pass


class UpdateObjectAttributesResponse(BaseModel):
    ObjectIdentifier_1: Optional[ObjectIdentifier] = Field(
        None, alias='ObjectIdentifier'
    )


class UpdateSchemaRequest(BaseModel):
    Name: SchemaName


class UpdateSchemaResponse(BaseModel):
    SchemaArn: Optional[Arn] = None


class UpdateTypedLinkFacetResponse(BaseModel):
    pass


class UpgradeAppliedSchemaRequest(BaseModel):
    DirectoryArn: Arn
    DryRun: Optional[Bool] = None
    PublishedSchemaArn: Arn


class UpgradeAppliedSchemaResponse(BaseModel):
    DirectoryArn: Optional[Arn] = None
    UpgradedSchemaArn: Optional[Arn] = None


class UpgradePublishedSchemaResponse(BaseModel):
    UpgradedSchemaArn: Optional[Arn] = None


class ValidationException(RootModel[Any]):
    root: Any


class Version(
    RootModel[constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=10)]
):
    root: constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=10)


class XAmzConsistencyLevel(Enum):
    SERIALIZABLE = 'SERIALIZABLE'
    EVENTUAL = 'EVENTUAL'


class Amazonclouddirectory20170111DirectoryCreateXAmzDataPartitionPutRequest(BaseModel):
    Name: constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=64) = Field(
        ...,
        description='The name of the <a>Directory</a>. Should be unique per account, per region.',
    )


class State(Enum):
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'
    DELETED = 'DELETED'


class Amazonclouddirectory20170111DirectoryListPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1)] = Field(
        None, description='The maximum number of results to retrieve.'
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')
    state: Optional[State] = Field(
        None,
        description='The state of the directories in the list. Can be either Enabled, Disabled, or Deleted.',
    )


class Amazonclouddirectory20170111FacetXAmzDataPartitionPostRequest(BaseModel):
    Name: constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=64) = Field(
        ..., description='The name of the facet to retrieve.'
    )


class Amazonclouddirectory20170111FacetAttributesXAmzDataPartitionPostRequest(
    BaseModel
):
    MaxResults: Optional[conint(ge=1)] = Field(
        None, description='The maximum number of results to retrieve.'
    )
    Name: constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=64) = Field(
        ..., description='The name of the facet whose attributes will be retrieved.'
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')


class Amazonclouddirectory20170111FacetDeleteXAmzDataPartitionPutRequest(BaseModel):
    Name: constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=64) = Field(
        ..., description='The name of the facet to delete.'
    )


class Amazonclouddirectory20170111FacetListXAmzDataPartitionPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1)] = Field(
        None, description='The maximum number of results to retrieve.'
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')


class ParentReference(BaseModel):
    Selector: Optional[SelectorObjectReference] = None


class IndexReference(BaseModel):
    Selector: Optional[SelectorObjectReference] = None


class TargetReference(BaseModel):
    Selector: Optional[SelectorObjectReference] = None


class Amazonclouddirectory20170111IndexAttachXAmzDataPartitionPutRequest(BaseModel):
    IndexReference_1: IndexReference = Field(
        ...,
        alias='IndexReference',
        description='The reference that identifies an object.',
    )
    TargetReference_1: TargetReference = Field(
        ...,
        alias='TargetReference',
        description='The reference that identifies an object.',
    )


class Amazonclouddirectory20170111IndexDetachXAmzDataPartitionPutRequest(BaseModel):
    IndexReference_1: IndexReference = Field(
        ...,
        alias='IndexReference',
        description='The reference that identifies an object.',
    )
    TargetReference_1: TargetReference = Field(
        ...,
        alias='TargetReference',
        description='The reference that identifies an object.',
    )


class ChildReference(BaseModel):
    Selector: Optional[SelectorObjectReference] = None


class Amazonclouddirectory20170111ObjectAttachXAmzDataPartitionPutRequest(BaseModel):
    ChildReference_1: ChildReference = Field(
        ...,
        alias='ChildReference',
        description='The reference that identifies an object.',
    )
    LinkName: constr(
        pattern=r'[^\/\[\]\(\):\{\}#@!?\s\\;]+', min_length=1, max_length=64
    ) = Field(
        ...,
        description='The link name with which the child object is attached to the parent.',
    )
    ParentReference_1: ParentReference = Field(
        ...,
        alias='ParentReference',
        description='The reference that identifies an object.',
    )


class FacetFilter(BaseModel):
    FacetName_1: Optional[FacetName] = Field(None, alias='FacetName')
    SchemaArn: Optional[Arn] = None


class ObjectReference(BaseModel):
    Selector: Optional[SelectorObjectReference] = None


class Amazonclouddirectory20170111ObjectAttributesXAmzDataPartitionPostRequest(
    BaseModel
):
    FacetFilter_1: Optional[FacetFilter] = Field(
        None, alias='FacetFilter', description='A facet.'
    )
    MaxResults: Optional[conint(ge=1)] = Field(
        None,
        description='The maximum number of items to be retrieved in a single call. This is an approximate number.',
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')
    ObjectReference_1: ObjectReference = Field(
        ...,
        alias='ObjectReference',
        description='The reference that identifies an object.',
    )


class Amazonclouddirectory20170111ObjectAttributesGetXAmzDataPartitionPostRequest(
    BaseModel
):
    AttributeNames: List[AttributeName] = Field(
        ..., description='List of attribute names whose values will be retrieved.'
    )
    ObjectReference_1: ObjectReference = Field(
        ...,
        alias='ObjectReference',
        description='The reference that identifies an object.',
    )
    SchemaFacet_1: SchemaFacet = Field(..., alias='SchemaFacet', description='A facet.')


class Amazonclouddirectory20170111ObjectChildrenXAmzDataPartitionPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1)] = Field(
        None,
        description='The maximum number of items to be retrieved in a single call. This is an approximate number.',
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')
    ObjectReference_1: ObjectReference = Field(
        ...,
        alias='ObjectReference',
        description='The reference that identifies an object.',
    )


class Amazonclouddirectory20170111ObjectDeleteXAmzDataPartitionPutRequest(BaseModel):
    ObjectReference_1: ObjectReference = Field(
        ...,
        alias='ObjectReference',
        description='The reference that identifies an object.',
    )


class Amazonclouddirectory20170111ObjectDetachXAmzDataPartitionPutRequest(BaseModel):
    LinkName: constr(
        pattern=r'[^\/\[\]\(\):\{\}#@!?\s\\;]+', min_length=1, max_length=64
    ) = Field(
        ...,
        description='The link name associated with the object that needs to be detached.',
    )
    ParentReference_1: ParentReference = Field(
        ...,
        alias='ParentReference',
        description='The reference that identifies an object.',
    )


class Amazonclouddirectory20170111ObjectFacetsDeleteXAmzDataPartitionPutRequest(
    BaseModel
):
    ObjectReference_1: ObjectReference = Field(
        ...,
        alias='ObjectReference',
        description='The reference that identifies an object.',
    )
    SchemaFacet_1: SchemaFacet = Field(..., alias='SchemaFacet', description='A facet.')


class Amazonclouddirectory20170111ObjectIndicesXAmzDataPartitionPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1)] = Field(
        None, description='The maximum number of results to retrieve.'
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')
    TargetReference_1: TargetReference = Field(
        ...,
        alias='TargetReference',
        description='The reference that identifies an object.',
    )


class Amazonclouddirectory20170111ObjectInformationXAmzDataPartitionPostRequest(
    BaseModel
):
    ObjectReference_1: ObjectReference = Field(
        ...,
        alias='ObjectReference',
        description='The reference that identifies an object.',
    )


class Amazonclouddirectory20170111ObjectParentXAmzDataPartitionPostRequest(BaseModel):
    IncludeAllLinksToEachParent: Optional[bool] = Field(
        None,
        description='When set to True, returns all <a>ListObjectParentsResponse$ParentLinks</a>. There could be multiple links between a parent-child pair.',
    )
    MaxResults: Optional[conint(ge=1)] = Field(
        None,
        description='The maximum number of items to be retrieved in a single call. This is an approximate number.',
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')
    ObjectReference_1: ObjectReference = Field(
        ...,
        alias='ObjectReference',
        description='The reference that identifies an object.',
    )


class Amazonclouddirectory20170111ObjectParentpathsXAmzDataPartitionPostRequest(
    BaseModel
):
    MaxResults: Optional[conint(ge=1)] = Field(
        None,
        description='The maximum number of items to be retrieved in a single call. This is an approximate number.',
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')
    ObjectReference_1: ObjectReference = Field(
        ...,
        alias='ObjectReference',
        description='The reference that identifies an object.',
    )


class Amazonclouddirectory20170111ObjectPolicyXAmzDataPartitionPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1)] = Field(
        None,
        description='The maximum number of items to be retrieved in a single call. This is an approximate number.',
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')
    ObjectReference_1: ObjectReference = Field(
        ...,
        alias='ObjectReference',
        description='The reference that identifies an object.',
    )


class PolicyReference(BaseModel):
    Selector: Optional[SelectorObjectReference] = None


class Amazonclouddirectory20170111PolicyAttachXAmzDataPartitionPutRequest(BaseModel):
    ObjectReference_1: ObjectReference = Field(
        ...,
        alias='ObjectReference',
        description='The reference that identifies an object.',
    )
    PolicyReference_1: PolicyReference = Field(
        ...,
        alias='PolicyReference',
        description='The reference that identifies an object.',
    )


class Amazonclouddirectory20170111PolicyAttachmentXAmzDataPartitionPostRequest(
    BaseModel
):
    MaxResults: Optional[conint(ge=1)] = Field(
        None,
        description='The maximum number of items to be retrieved in a single call. This is an approximate number.',
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')
    PolicyReference_1: PolicyReference = Field(
        ...,
        alias='PolicyReference',
        description='The reference that identifies an object.',
    )


class Amazonclouddirectory20170111PolicyDetachXAmzDataPartitionPutRequest(BaseModel):
    ObjectReference_1: ObjectReference = Field(
        ...,
        alias='ObjectReference',
        description='The reference that identifies an object.',
    )
    PolicyReference_1: PolicyReference = Field(
        ...,
        alias='PolicyReference',
        description='The reference that identifies an object.',
    )


class Amazonclouddirectory20170111PolicyLookupXAmzDataPartitionPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1)] = Field(
        None,
        description='The maximum number of items to be retrieved in a single call. This is an approximate number.',
    )
    NextToken: Optional[str] = Field(
        None, description='The token to request the next page of results.'
    )
    ObjectReference_1: ObjectReference = Field(
        ...,
        alias='ObjectReference',
        description='The reference that identifies an object.',
    )


class Amazonclouddirectory20170111SchemaAppliedPostRequest(BaseModel):
    DirectoryArn: str = Field(
        ..., description='The ARN of the directory you are listing.'
    )
    MaxResults: Optional[conint(ge=1)] = Field(
        None, description='The maximum number of results to retrieve.'
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')
    SchemaArn: Optional[str] = Field(
        None,
        description='The response for <code>ListAppliedSchemaArns</code> when this parameter is used will list all minor version ARNs for a major version.',
    )


class Amazonclouddirectory20170111SchemaApplyXAmzDataPartitionPutRequest(BaseModel):
    PublishedSchemaArn: str = Field(
        ...,
        description='Published schema Amazon Resource Name (ARN) that needs to be copied. For more information, see <a>arns</a>.',
    )


class Amazonclouddirectory20170111SchemaCreatePutRequest(BaseModel):
    Name: constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=32) = Field(
        ...,
        description='The name that is associated with the schema. This is unique to each account and in each region.',
    )


class Amazonclouddirectory20170111SchemaDevelopmentPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1)] = Field(
        None, description='The maximum number of results to retrieve.'
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')


class Amazonclouddirectory20170111SchemaGetappliedschemaPostRequest(BaseModel):
    SchemaArn: str = Field(..., description='The ARN of the applied schema.')


class Amazonclouddirectory20170111SchemaJsonXAmzDataPartitionPutRequest(BaseModel):
    Document: str = Field(..., description='The replacement JSON schema.')


class Amazonclouddirectory20170111SchemaManagedPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1)] = Field(
        None, description='The maximum number of results to retrieve.'
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')
    SchemaArn: Optional[str] = Field(
        None,
        description='The response for ListManagedSchemaArns. When this parameter is used, all minor version ARNs for a major version are listed.',
    )


class Amazonclouddirectory20170111SchemaPublishXAmzDataPartitionPutRequest(BaseModel):
    MinorVersion: Optional[
        constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=10)
    ] = Field(
        None,
        description='The minor version under which the schema will be published. This parameter is recommended. Schemas have both a major and minor version associated with them.',
    )
    Name: Optional[
        constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=32)
    ] = Field(
        None,
        description='The new name under which the schema will be published. If this is not provided, the development schema is considered.',
    )
    Version: constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=10) = Field(
        ...,
        description='The major version under which the schema will be published. Schemas have both a major and minor version associated with them.',
    )


class Amazonclouddirectory20170111SchemaPublishedPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1)] = Field(
        None, description='The maximum number of results to retrieve.'
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')
    SchemaArn: Optional[str] = Field(
        None,
        description='The response for <code>ListPublishedSchemaArns</code> when this parameter is used will list all minor version ARNs for a major version.',
    )


class Amazonclouddirectory20170111SchemaUpdateXAmzDataPartitionPutRequest(BaseModel):
    Name: constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=32) = Field(
        ..., description='The name of the schema.'
    )


class Amazonclouddirectory20170111SchemaUpgradeappliedPutRequest(BaseModel):
    DirectoryArn: str = Field(
        ...,
        description='The ARN for the directory to which the upgraded schema will be applied.',
    )
    DryRun: Optional[bool] = Field(
        None,
        description='Used for testing whether the major version schemas are backward compatible or not. If schema compatibility fails, an exception would be thrown else the call would succeed but no changes will be saved. This parameter is optional.',
    )
    PublishedSchemaArn: str = Field(
        ...,
        description='The revision of the published schema to upgrade the directory to.',
    )


class Amazonclouddirectory20170111SchemaUpgradepublishedPutRequest(BaseModel):
    DevelopmentSchemaArn: str = Field(
        ...,
        description='The ARN of the development schema with the changes used for the upgrade.',
    )
    DryRun: Optional[bool] = Field(
        None,
        description='Used for testing whether the Development schema provided is backwards compatible, or not, with the publish schema provided by the user to be upgraded. If schema compatibility fails, an exception would be thrown else the call would succeed. This parameter is optional and defaults to false.',
    )
    MinorVersion: constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=10) = (
        Field(
            ...,
            description='Identifies the minor version of the published schema that will be created. This parameter is NOT optional.',
        )
    )
    PublishedSchemaArn: str = Field(
        ..., description='The ARN of the published schema to be upgraded.'
    )


class Amazonclouddirectory20170111TagsPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=50)] = Field(
        None,
        description='The <code>MaxResults</code> parameter sets the maximum number of results returned in a single page. This is for future use and is not supported currently.',
    )
    NextToken: Optional[str] = Field(
        None,
        description='The pagination token. This is for future use. Currently pagination is not supported for tagging.',
    )
    ResourceArn: str = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the resource. Tagging is only supported for directories.',
    )


class Amazonclouddirectory20170111TagsRemovePutRequest(BaseModel):
    ResourceArn: str = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the resource. Tagging is only supported for directories.',
    )
    TagKeys: List[TagKey] = Field(
        ..., description='Keys of the tag that need to be removed from the resource.'
    )


class SourceObjectReference(BaseModel):
    Selector: Optional[SelectorObjectReference] = None


class TargetObjectReference(BaseModel):
    Selector: Optional[SelectorObjectReference] = None


class TypedLinkFacet1(BaseModel):
    SchemaArn: Optional[Arn] = None
    TypedLinkName_1: Optional[TypedLinkName] = Field(None, alias='TypedLinkName')


class Amazonclouddirectory20170111TypedlinkFacetAttributesXAmzDataPartitionPostRequest(
    BaseModel
):
    MaxResults: Optional[conint(ge=1)] = Field(
        None, description='The maximum number of results to retrieve.'
    )
    Name: constr(pattern=r'^[a-zA-Z0-9._-]*$') = Field(
        ..., description='The unique name of the typed link facet.'
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')


class Amazonclouddirectory20170111TypedlinkFacetDeleteXAmzDataPartitionPutRequest(
    BaseModel
):
    Name: constr(pattern=r'^[a-zA-Z0-9._-]*$') = Field(
        ..., description='The unique name of the typed link facet.'
    )


class Amazonclouddirectory20170111TypedlinkFacetGetXAmzDataPartitionPostRequest(
    BaseModel
):
    Name: constr(pattern=r'^[a-zA-Z0-9._-]*$') = Field(
        ..., description='The unique name of the typed link facet.'
    )


class Amazonclouddirectory20170111TypedlinkFacetListXAmzDataPartitionPostRequest(
    BaseModel
):
    MaxResults: Optional[conint(ge=1)] = Field(
        None, description='The maximum number of results to retrieve.'
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')


class FilterTypedLink(BaseModel):
    SchemaArn: Optional[Arn] = None
    TypedLinkName_1: Optional[TypedLinkName] = Field(None, alias='TypedLinkName')


class Amazonclouddirectory20170111TypedlinkIncomingXAmzDataPartitionPostRequest(
    BaseModel
):
    ConsistencyLevel_1: Optional[ConsistencyLevel] = Field(
        None,
        alias='ConsistencyLevel',
        description='The consistency level to execute the request at.',
    )
    FilterAttributeRanges: Optional[List[TypedLinkAttributeRange]] = Field(
        None,
        description='Provides range filters for multiple attributes. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range.',
    )
    FilterTypedLink_1: Optional[FilterTypedLink] = Field(
        None,
        alias='FilterTypedLink',
        description='Identifies the schema Amazon Resource Name (ARN) and facet name for the typed link.',
    )
    MaxResults: Optional[conint(ge=1)] = Field(
        None, description='The maximum number of results to retrieve.'
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')
    ObjectReference_1: ObjectReference = Field(
        ...,
        alias='ObjectReference',
        description='The reference that identifies an object.',
    )


class Amazonclouddirectory20170111TypedlinkOutgoingXAmzDataPartitionPostRequest(
    BaseModel
):
    ConsistencyLevel_1: Optional[ConsistencyLevel] = Field(
        None,
        alias='ConsistencyLevel',
        description='The consistency level to execute the request at.',
    )
    FilterAttributeRanges: Optional[List[TypedLinkAttributeRange]] = Field(
        None,
        description='Provides range filters for multiple attributes. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range.',
    )
    FilterTypedLink_1: Optional[FilterTypedLink] = Field(
        None,
        alias='FilterTypedLink',
        description='Identifies the schema Amazon Resource Name (ARN) and facet name for the typed link.',
    )
    MaxResults: Optional[conint(ge=1)] = Field(
        None, description='The maximum number of results to retrieve.'
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')
    ObjectReference_1: ObjectReference = Field(
        ...,
        alias='ObjectReference',
        description='The reference that identifies an object.',
    )


class ApplySchemaRequest(BaseModel):
    PublishedSchemaArn: Arn


class ApplySchemaResponse(BaseModel):
    AppliedSchemaArn: Optional[Arn] = None
    DirectoryArn: Optional[Arn] = None


class AttachObjectResponse(BaseModel):
    AttachedObjectIdentifier: Optional[ObjectIdentifier] = None


class AttachToIndexResponse(BaseModel):
    AttachedObjectIdentifier: Optional[ObjectIdentifier] = None


class AttributeKey(BaseModel):
    FacetName_1: FacetName = Field(..., alias='FacetName')
    Name: AttributeName
    SchemaArn: Arn


class AttributeKeyAndValue(BaseModel):
    Key: AttributeKey
    Value: TypedAttributeValue


class AttributeKeyAndValueList(RootModel[List[AttributeKeyAndValue]]):
    root: List[AttributeKeyAndValue]


class AttributeKeyList(RootModel[List[AttributeKey]]):
    root: List[AttributeKey]


class AttributeNameAndValue(BaseModel):
    AttributeName_1: AttributeName = Field(..., alias='AttributeName')
    Value: TypedAttributeValue


class AttributeNameAndValueList(RootModel[List[AttributeNameAndValue]]):
    root: List[AttributeNameAndValue]


class BatchAttachObjectResponse(BaseModel):
    attachedObjectIdentifier: Optional[ObjectIdentifier] = None


class BatchAttachToIndexResponse(BaseModel):
    AttachedObjectIdentifier: Optional[ObjectIdentifier] = None


class BatchCreateIndexResponse(BaseModel):
    ObjectIdentifier_1: Optional[ObjectIdentifier] = Field(
        None, alias='ObjectIdentifier'
    )


class BatchCreateObjectResponse(BaseModel):
    ObjectIdentifier_1: Optional[ObjectIdentifier] = Field(
        None, alias='ObjectIdentifier'
    )


class BatchDetachFromIndexResponse(BaseModel):
    DetachedObjectIdentifier: Optional[ObjectIdentifier] = None


class BatchDetachObjectResponse(BaseModel):
    detachedObjectIdentifier: Optional[ObjectIdentifier] = None


class BatchGetLinkAttributesResponse(BaseModel):
    Attributes: Optional[AttributeKeyAndValueList] = None


class BatchGetObjectAttributesResponse(BaseModel):
    Attributes: Optional[AttributeKeyAndValueList] = None


class BatchGetObjectInformationResponse(BaseModel):
    ObjectIdentifier_1: Optional[ObjectIdentifier] = Field(
        None, alias='ObjectIdentifier'
    )
    SchemaFacets: Optional[SchemaFacetList] = None


class BatchListObjectAttributesResponse(BaseModel):
    Attributes: Optional[AttributeKeyAndValueList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class BatchListObjectParentPathsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    PathToObjectIdentifiersList_1: Optional[PathToObjectIdentifiersList] = Field(
        None, alias='PathToObjectIdentifiersList'
    )


class BatchListObjectPoliciesResponse(BaseModel):
    AttachedPolicyIds: Optional[ObjectIdentifierList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class BatchListPolicyAttachmentsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectIdentifiers: Optional[ObjectIdentifierList] = None


class BatchReadException(BaseModel):
    Message: Optional[ExceptionMessage] = None
    Type: Optional[BatchReadExceptionType] = None


class BatchUpdateObjectAttributesResponse(BaseModel):
    ObjectIdentifier_1: Optional[ObjectIdentifier] = Field(
        None, alias='ObjectIdentifier'
    )


class CreateDirectoryRequest(BaseModel):
    Name: DirectoryName


class CreateDirectoryResponse(BaseModel):
    AppliedSchemaArn: Arn
    DirectoryArn_1: DirectoryArn = Field(..., alias='DirectoryArn')
    Name: DirectoryName
    ObjectIdentifier_1: ObjectIdentifier = Field(..., alias='ObjectIdentifier')


class CreateIndexResponse(BaseModel):
    ObjectIdentifier_1: Optional[ObjectIdentifier] = Field(
        None, alias='ObjectIdentifier'
    )


class CreateObjectResponse(BaseModel):
    ObjectIdentifier_1: Optional[ObjectIdentifier] = Field(
        None, alias='ObjectIdentifier'
    )


class CreateSchemaRequest(BaseModel):
    Name: SchemaName


class DeleteFacetRequest(BaseModel):
    Name: FacetName


class DeleteTypedLinkFacetRequest(BaseModel):
    Name: TypedLinkName


class DetachFromIndexResponse(BaseModel):
    DetachedObjectIdentifier: Optional[ObjectIdentifier] = None


class DetachObjectResponse(BaseModel):
    DetachedObjectIdentifier: Optional[ObjectIdentifier] = None


class Directory(BaseModel):
    CreationDateTime: Optional[Date] = None
    DirectoryArn_1: Optional[DirectoryArn] = Field(None, alias='DirectoryArn')
    Name: Optional[DirectoryName] = None
    State: Optional[DirectoryState] = None


class DirectoryList(RootModel[List[Directory]]):
    root: List[Directory]


class Facet(BaseModel):
    FacetStyle_1: Optional[FacetStyle] = Field(None, alias='FacetStyle')
    Name: Optional[FacetName] = None
    ObjectType_1: Optional[ObjectType] = Field(None, alias='ObjectType')


class FacetAttributeReference(BaseModel):
    TargetAttributeName: AttributeName
    TargetFacetName: FacetName


class GetDirectoryResponse(BaseModel):
    Directory_1: Directory = Field(..., alias='Directory')


class GetFacetResponse(BaseModel):
    Facet_1: Optional[Facet] = Field(None, alias='Facet')


class GetLinkAttributesResponse(BaseModel):
    Attributes: Optional[AttributeKeyAndValueList] = None


class GetObjectAttributesResponse(BaseModel):
    Attributes: Optional[AttributeKeyAndValueList] = None


class GetObjectInformationResponse(BaseModel):
    ObjectIdentifier_1: Optional[ObjectIdentifier] = Field(
        None, alias='ObjectIdentifier'
    )
    SchemaFacets: Optional[SchemaFacetList] = None


class GetSchemaAsJsonResponse(BaseModel):
    Document: Optional[SchemaJsonDocument] = None
    Name: Optional[SchemaName] = None


class GetTypedLinkFacetInformationRequest(BaseModel):
    Name: TypedLinkName


class IndexAttachment(BaseModel):
    IndexedAttributes: Optional[AttributeKeyAndValueList] = None
    ObjectIdentifier_1: Optional[ObjectIdentifier] = Field(
        None, alias='ObjectIdentifier'
    )


class IndexAttachmentList(RootModel[List[IndexAttachment]]):
    root: List[IndexAttachment]


class LinkAttributeAction(BaseModel):
    AttributeActionType: Optional[UpdateActionType] = None
    AttributeUpdateValue: Optional[TypedAttributeValue] = None


class LinkAttributeUpdate(BaseModel):
    AttributeAction: Optional[LinkAttributeAction] = None
    AttributeKey_1: Optional[AttributeKey] = Field(None, alias='AttributeKey')


class LinkAttributeUpdateList(RootModel[List[LinkAttributeUpdate]]):
    root: List[LinkAttributeUpdate]


class LinkNameToObjectIdentifierMap(RootModel[Optional[Dict[str, ObjectIdentifier]]]):
    root: Optional[Dict[str, ObjectIdentifier]] = None


class ListAppliedSchemaArnsRequest(BaseModel):
    DirectoryArn: Arn
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    SchemaArn: Optional[Arn] = None


class ListAppliedSchemaArnsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    SchemaArns: Optional[Arns] = None


class ListAttachedIndicesResponse(BaseModel):
    IndexAttachments: Optional[IndexAttachmentList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListDevelopmentSchemaArnsRequest(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListDevelopmentSchemaArnsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    SchemaArns: Optional[Arns] = None


class ListDirectoriesRequest(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    state: Optional[DirectoryState] = None


class ListDirectoriesResponse(BaseModel):
    Directories: DirectoryList
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListFacetAttributesRequest(BaseModel):
    MaxResults: Optional[NumberResults] = None
    Name: FacetName
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListFacetNamesRequest(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListFacetNamesResponse(BaseModel):
    FacetNames: Optional[FacetNameList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListIndexResponse(BaseModel):
    IndexAttachments: Optional[IndexAttachmentList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListManagedSchemaArnsRequest(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    SchemaArn: Optional[Arn] = None


class ListManagedSchemaArnsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    SchemaArns: Optional[Arns] = None


class ListObjectAttributesResponse(BaseModel):
    Attributes: Optional[AttributeKeyAndValueList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListObjectChildrenResponse(BaseModel):
    Children: Optional[LinkNameToObjectIdentifierMap] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListObjectParentPathsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    PathToObjectIdentifiersList_1: Optional[PathToObjectIdentifiersList] = Field(
        None, alias='PathToObjectIdentifiersList'
    )


class ListObjectPoliciesResponse(BaseModel):
    AttachedPolicyIds: Optional[ObjectIdentifierList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListPolicyAttachmentsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectIdentifiers: Optional[ObjectIdentifierList] = None


class ListPublishedSchemaArnsRequest(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    SchemaArn: Optional[Arn] = None


class ListPublishedSchemaArnsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    SchemaArns: Optional[Arns] = None


class ListTagsForResourceRequest(BaseModel):
    MaxResults: Optional[TagsNumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ResourceArn: Arn


class ListTypedLinkFacetAttributesRequest(BaseModel):
    MaxResults: Optional[NumberResults] = None
    Name: TypedLinkName
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListTypedLinkFacetNamesRequest(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListTypedLinkFacetNamesResponse(BaseModel):
    FacetNames: Optional[TypedLinkNameList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ObjectAttributeAction(BaseModel):
    ObjectAttributeActionType: Optional[UpdateActionType] = None
    ObjectAttributeUpdateValue: Optional[TypedAttributeValue] = None


class ObjectAttributeRange(BaseModel):
    AttributeKey_1: Optional[AttributeKey] = Field(None, alias='AttributeKey')
    Range: Optional[TypedAttributeValueRange] = None


class ObjectAttributeRangeList(RootModel[List[ObjectAttributeRange]]):
    root: List[ObjectAttributeRange]


class ObjectAttributeUpdate(BaseModel):
    ObjectAttributeAction_1: Optional[ObjectAttributeAction] = Field(
        None, alias='ObjectAttributeAction'
    )
    ObjectAttributeKey: Optional[AttributeKey] = None


class ObjectAttributeUpdateList(RootModel[List[ObjectAttributeUpdate]]):
    root: List[ObjectAttributeUpdate]


class ObjectIdentifierAndLinkNameList(
    RootModel[List[ObjectIdentifierAndLinkNameTuple]]
):
    root: List[ObjectIdentifierAndLinkNameTuple]


class PolicyAttachment(BaseModel):
    ObjectIdentifier_1: Optional[ObjectIdentifier] = Field(
        None, alias='ObjectIdentifier'
    )
    PolicyId: Optional[ObjectIdentifier] = None
    PolicyType_1: Optional[PolicyType] = Field(None, alias='PolicyType')


class PolicyAttachmentList(RootModel[List[PolicyAttachment]]):
    root: List[PolicyAttachment]


class PolicyToPath(BaseModel):
    Path: Optional[PathString] = None
    Policies: Optional[PolicyAttachmentList] = None


class PolicyToPathList(RootModel[List[PolicyToPath]]):
    root: List[PolicyToPath]


class PublishSchemaRequest(BaseModel):
    MinorVersion: Optional[Version] = None
    Name: Optional[SchemaName] = None
    Version_1: Version = Field(..., alias='Version')


class PutSchemaFromJsonRequest(BaseModel):
    Document: SchemaJsonDocument


class RemoveFacetFromObjectRequest(BaseModel):
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')
    SchemaFacet_1: SchemaFacet = Field(..., alias='SchemaFacet')


class RuleParameterMap(RootModel[Optional[Dict[str, RuleParameterValue]]]):
    root: Optional[Dict[str, RuleParameterValue]] = None


class Tag(BaseModel):
    Key: Optional[TagKey] = None
    Value: Optional[TagValue] = None


class TagList(RootModel[List[Tag]]):
    root: List[Tag]


class TagResourceRequest(BaseModel):
    ResourceArn: Arn
    Tags: TagList


class TypedLinkSpecifier(BaseModel):
    IdentityAttributeValues: AttributeNameAndValueList
    SourceObjectReference: ObjectReference
    TargetObjectReference: ObjectReference
    TypedLinkFacet: TypedLinkSchemaAndFacetName


class TypedLinkSpecifierList(RootModel[List[TypedLinkSpecifier]]):
    root: List[TypedLinkSpecifier]


class UpdateLinkAttributesRequest(BaseModel):
    AttributeUpdates: LinkAttributeUpdateList
    TypedLinkSpecifier_1: TypedLinkSpecifier = Field(..., alias='TypedLinkSpecifier')


class UpdateObjectAttributesRequest(BaseModel):
    AttributeUpdates: ObjectAttributeUpdateList
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class UpgradePublishedSchemaRequest(BaseModel):
    DevelopmentSchemaArn: Arn
    DryRun: Optional[Bool] = None
    MinorVersion: Version
    PublishedSchemaArn: Arn


class Amazonclouddirectory20170111IndexXAmzDataPartitionPutRequest(BaseModel):
    IsUnique: bool = Field(
        ...,
        description='Indicates whether the attribute that is being indexed has unique values or not.',
    )
    LinkName: Optional[
        constr(pattern=r'[^\/\[\]\(\):\{\}#@!?\s\\;]+', min_length=1, max_length=64)
    ] = Field(
        None,
        description='The name of the link between the parent object and the index object.',
    )
    OrderedIndexedAttributeList: List[AttributeKey] = Field(
        ...,
        description='Specifies the attributes that should be indexed on. Currently only a single attribute is supported.',
    )
    ParentReference_1: Optional[ParentReference] = Field(
        None,
        alias='ParentReference',
        description='The reference that identifies an object.',
    )


class Amazonclouddirectory20170111IndexTargetsXAmzDataPartitionPostRequest(BaseModel):
    IndexReference_1: IndexReference = Field(
        ...,
        alias='IndexReference',
        description='The reference that identifies an object.',
    )
    MaxResults: Optional[conint(ge=1)] = Field(
        None,
        description='The maximum number of objects in a single page to retrieve from the index during a request. For more information, see <a href="http://docs.aws.amazon.com/clouddirectory/latest/developerguide/limits.html">Amazon Cloud Directory Limits</a>.',
    )
    NextToken: Optional[str] = Field(None, description='The pagination token.')
    RangesOnIndexedValues: Optional[List[ObjectAttributeRange]] = Field(
        None,
        description='Specifies the ranges of indexed values that you want to query.',
    )


class Amazonclouddirectory20170111ObjectXAmzDataPartitionPutRequest(BaseModel):
    LinkName: Optional[
        constr(pattern=r'[^\/\[\]\(\):\{\}#@!?\s\\;]+', min_length=1, max_length=64)
    ] = Field(
        None,
        description='The name of link that is used to attach this object to a parent.',
    )
    ObjectAttributeList: Optional[List[AttributeKeyAndValue]] = Field(
        None,
        description='The attribute map whose attribute ARN contains the key and attribute value as the map value.',
    )
    ParentReference_1: Optional[ParentReference] = Field(
        None,
        alias='ParentReference',
        description='The reference that identifies an object.',
    )
    SchemaFacets: List[SchemaFacet] = Field(
        ...,
        description='A list of schema facets to be associated with the object. Do not provide minor version components. See <a>SchemaFacet</a> for details.',
    )


class Amazonclouddirectory20170111ObjectFacetsXAmzDataPartitionPutRequest(BaseModel):
    ObjectAttributeList: Optional[List[AttributeKeyAndValue]] = Field(
        None, description='Attributes on the facet that you are adding to the object.'
    )
    ObjectReference_1: ObjectReference = Field(
        ...,
        alias='ObjectReference',
        description='The reference that identifies an object.',
    )
    SchemaFacet_1: SchemaFacet = Field(..., alias='SchemaFacet', description='A facet.')


class Amazonclouddirectory20170111ObjectUpdateXAmzDataPartitionPutRequest(BaseModel):
    AttributeUpdates: List[ObjectAttributeUpdate] = Field(
        ..., description='The attributes update structure.'
    )
    ObjectReference_1: ObjectReference = Field(
        ...,
        alias='ObjectReference',
        description='The reference that identifies an object.',
    )


class Amazonclouddirectory20170111TagsAddPutRequest(BaseModel):
    ResourceArn: str = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the resource. Tagging is only supported for directories.',
    )
    Tags: List[Tag] = Field(..., description='A list of tag key-value pairs.')


class Amazonclouddirectory20170111TypedlinkAttachXAmzDataPartitionPutRequest(BaseModel):
    Attributes: List[AttributeNameAndValue] = Field(
        ..., description='A set of attributes that are associated with the typed link.'
    )
    SourceObjectReference_1: SourceObjectReference = Field(
        ...,
        alias='SourceObjectReference',
        description='The reference that identifies an object.',
    )
    TargetObjectReference_1: TargetObjectReference = Field(
        ...,
        alias='TargetObjectReference',
        description='The reference that identifies an object.',
    )
    TypedLinkFacet: TypedLinkFacet1 = Field(
        ...,
        description='Identifies the schema Amazon Resource Name (ARN) and facet name for the typed link.',
    )


class TypedLinkSpecifier1(BaseModel):
    IdentityAttributeValues: Optional[AttributeNameAndValueList] = None
    SourceObjectReference: Optional[ObjectReference] = None
    TargetObjectReference: Optional[ObjectReference] = None
    TypedLinkFacet: Optional[TypedLinkSchemaAndFacetName] = None


class Amazonclouddirectory20170111TypedlinkAttributesGetXAmzDataPartitionPostRequest(
    BaseModel
):
    AttributeNames: List[AttributeName] = Field(
        ..., description='A list of attribute names whose values will be retrieved.'
    )
    ConsistencyLevel_1: Optional[ConsistencyLevel] = Field(
        None,
        alias='ConsistencyLevel',
        description='The consistency level at which to retrieve the attributes on a typed link.',
    )
    TypedLinkSpecifier: TypedLinkSpecifier1 = Field(
        ...,
        description='Contains all the information that is used to uniquely identify a typed link. The parameters discussed in this topic are used to uniquely specify the typed link being operated on. The <a>AttachTypedLink</a> API returns a typed link specifier while the <a>DetachTypedLink</a> API accepts one as input. Similarly, the <a>ListIncomingTypedLinks</a> and <a>ListOutgoingTypedLinks</a> API operations provide typed link specifiers as output. You can also construct a typed link specifier from scratch.',
    )


class Amazonclouddirectory20170111TypedlinkAttributesUpdateXAmzDataPartitionPostRequest(
    BaseModel
):
    AttributeUpdates: List[LinkAttributeUpdate] = Field(
        ..., description='The attributes update structure.'
    )
    TypedLinkSpecifier: TypedLinkSpecifier1 = Field(
        ...,
        description='Contains all the information that is used to uniquely identify a typed link. The parameters discussed in this topic are used to uniquely specify the typed link being operated on. The <a>AttachTypedLink</a> API returns a typed link specifier while the <a>DetachTypedLink</a> API accepts one as input. Similarly, the <a>ListIncomingTypedLinks</a> and <a>ListOutgoingTypedLinks</a> API operations provide typed link specifiers as output. You can also construct a typed link specifier from scratch.',
    )


class Amazonclouddirectory20170111TypedlinkDetachXAmzDataPartitionPutRequest(BaseModel):
    TypedLinkSpecifier: TypedLinkSpecifier1 = Field(
        ...,
        description='Contains all the information that is used to uniquely identify a typed link. The parameters discussed in this topic are used to uniquely specify the typed link being operated on. The <a>AttachTypedLink</a> API returns a typed link specifier while the <a>DetachTypedLink</a> API accepts one as input. Similarly, the <a>ListIncomingTypedLinks</a> and <a>ListOutgoingTypedLinks</a> API operations provide typed link specifiers as output. You can also construct a typed link specifier from scratch.',
    )


class AddFacetToObjectRequest(BaseModel):
    ObjectAttributeList: Optional[AttributeKeyAndValueList] = None
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')
    SchemaFacet_1: SchemaFacet = Field(..., alias='SchemaFacet')


class AttachObjectRequest(BaseModel):
    ChildReference: ObjectReference
    LinkName_1: LinkName = Field(..., alias='LinkName')
    ParentReference: ObjectReference


class AttachPolicyRequest(BaseModel):
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')
    PolicyReference: ObjectReference


class AttachToIndexRequest(BaseModel):
    IndexReference: ObjectReference
    TargetReference: ObjectReference


class AttachTypedLinkRequest(BaseModel):
    Attributes: AttributeNameAndValueList
    SourceObjectReference: ObjectReference
    TargetObjectReference: ObjectReference
    TypedLinkFacet: TypedLinkSchemaAndFacetName


class AttachTypedLinkResponse(BaseModel):
    TypedLinkSpecifier_1: Optional[TypedLinkSpecifier] = Field(
        None, alias='TypedLinkSpecifier'
    )


class BatchAddFacetToObject(BaseModel):
    ObjectAttributeList: AttributeKeyAndValueList
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')
    SchemaFacet_1: SchemaFacet = Field(..., alias='SchemaFacet')


class BatchAttachObject(BaseModel):
    ChildReference: ObjectReference
    LinkName_1: LinkName = Field(..., alias='LinkName')
    ParentReference: ObjectReference


class BatchAttachPolicy(BaseModel):
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')
    PolicyReference: ObjectReference


class BatchAttachToIndex(BaseModel):
    IndexReference: ObjectReference
    TargetReference: ObjectReference


class BatchAttachTypedLink(BaseModel):
    Attributes: AttributeNameAndValueList
    SourceObjectReference: ObjectReference
    TargetObjectReference: ObjectReference
    TypedLinkFacet: TypedLinkSchemaAndFacetName


class BatchAttachTypedLinkResponse(BaseModel):
    TypedLinkSpecifier_1: Optional[TypedLinkSpecifier] = Field(
        None, alias='TypedLinkSpecifier'
    )


class BatchCreateIndex(BaseModel):
    BatchReferenceName_1: Optional[BatchReferenceName] = Field(
        None, alias='BatchReferenceName'
    )
    IsUnique: Bool
    LinkName_1: Optional[LinkName] = Field(None, alias='LinkName')
    OrderedIndexedAttributeList: AttributeKeyList
    ParentReference: Optional[ObjectReference] = None


class BatchCreateObject(BaseModel):
    BatchReferenceName_1: Optional[BatchReferenceName] = Field(
        None, alias='BatchReferenceName'
    )
    LinkName_1: Optional[LinkName] = Field(None, alias='LinkName')
    ObjectAttributeList: AttributeKeyAndValueList
    ParentReference: Optional[ObjectReference] = None
    SchemaFacet: SchemaFacetList


class BatchDeleteObject(BaseModel):
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class BatchDetachFromIndex(BaseModel):
    IndexReference: ObjectReference
    TargetReference: ObjectReference


class BatchDetachObject(BaseModel):
    BatchReferenceName_1: Optional[BatchReferenceName] = Field(
        None, alias='BatchReferenceName'
    )
    LinkName_1: LinkName = Field(..., alias='LinkName')
    ParentReference: ObjectReference


class BatchDetachPolicy(BaseModel):
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')
    PolicyReference: ObjectReference


class BatchDetachTypedLink(BaseModel):
    TypedLinkSpecifier_1: TypedLinkSpecifier = Field(..., alias='TypedLinkSpecifier')


class BatchGetLinkAttributes(BaseModel):
    AttributeNames: AttributeNameList
    TypedLinkSpecifier_1: TypedLinkSpecifier = Field(..., alias='TypedLinkSpecifier')


class BatchGetObjectAttributes(BaseModel):
    AttributeNames: AttributeNameList
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')
    SchemaFacet_1: SchemaFacet = Field(..., alias='SchemaFacet')


class BatchGetObjectInformation(BaseModel):
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class BatchListAttachedIndices(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    TargetReference: ObjectReference


class BatchListAttachedIndicesResponse(BaseModel):
    IndexAttachments: Optional[IndexAttachmentList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class BatchListIncomingTypedLinks(BaseModel):
    FilterAttributeRanges: Optional[TypedLinkAttributeRangeList] = None
    FilterTypedLink: Optional[TypedLinkSchemaAndFacetName] = None
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class BatchListIncomingTypedLinksResponse(BaseModel):
    LinkSpecifiers: Optional[TypedLinkSpecifierList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class BatchListIndex(BaseModel):
    IndexReference: ObjectReference
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    RangesOnIndexedValues: Optional[ObjectAttributeRangeList] = None


class BatchListIndexResponse(BaseModel):
    IndexAttachments: Optional[IndexAttachmentList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class BatchListObjectAttributes(BaseModel):
    FacetFilter: Optional[SchemaFacet] = None
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class BatchListObjectChildren(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class BatchListObjectChildrenResponse(BaseModel):
    Children: Optional[LinkNameToObjectIdentifierMap] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class BatchListObjectParentPaths(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class BatchListObjectParents(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class BatchListObjectParentsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ParentLinks: Optional[ObjectIdentifierAndLinkNameList] = None


class BatchListObjectPolicies(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class BatchListOutgoingTypedLinks(BaseModel):
    FilterAttributeRanges: Optional[TypedLinkAttributeRangeList] = None
    FilterTypedLink: Optional[TypedLinkSchemaAndFacetName] = None
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class BatchListOutgoingTypedLinksResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    TypedLinkSpecifiers: Optional[TypedLinkSpecifierList] = None


class BatchListPolicyAttachments(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    PolicyReference: ObjectReference


class BatchLookupPolicy(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class BatchLookupPolicyResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    PolicyToPathList_1: Optional[PolicyToPathList] = Field(
        None, alias='PolicyToPathList'
    )


class BatchReadOperation(BaseModel):
    GetLinkAttributes: Optional[BatchGetLinkAttributes] = None
    GetObjectAttributes: Optional[BatchGetObjectAttributes] = None
    GetObjectInformation: Optional[BatchGetObjectInformation] = None
    ListAttachedIndices: Optional[BatchListAttachedIndices] = None
    ListIncomingTypedLinks: Optional[BatchListIncomingTypedLinks] = None
    ListIndex: Optional[BatchListIndex] = None
    ListObjectAttributes: Optional[BatchListObjectAttributes] = None
    ListObjectChildren: Optional[BatchListObjectChildren] = None
    ListObjectParentPaths: Optional[BatchListObjectParentPaths] = None
    ListObjectParents: Optional[BatchListObjectParents] = None
    ListObjectPolicies: Optional[BatchListObjectPolicies] = None
    ListOutgoingTypedLinks: Optional[BatchListOutgoingTypedLinks] = None
    ListPolicyAttachments: Optional[BatchListPolicyAttachments] = None
    LookupPolicy: Optional[BatchLookupPolicy] = None


class BatchReadOperationList(RootModel[List[BatchReadOperation]]):
    root: List[BatchReadOperation]


class BatchReadRequest(BaseModel):
    Operations: BatchReadOperationList


class BatchReadSuccessfulResponse(BaseModel):
    GetLinkAttributes: Optional[BatchGetLinkAttributesResponse] = None
    GetObjectAttributes: Optional[BatchGetObjectAttributesResponse] = None
    GetObjectInformation: Optional[BatchGetObjectInformationResponse] = None
    ListAttachedIndices: Optional[BatchListAttachedIndicesResponse] = None
    ListIncomingTypedLinks: Optional[BatchListIncomingTypedLinksResponse] = None
    ListIndex: Optional[BatchListIndexResponse] = None
    ListObjectAttributes: Optional[BatchListObjectAttributesResponse] = None
    ListObjectChildren: Optional[BatchListObjectChildrenResponse] = None
    ListObjectParentPaths: Optional[BatchListObjectParentPathsResponse] = None
    ListObjectParents: Optional[BatchListObjectParentsResponse] = None
    ListObjectPolicies: Optional[BatchListObjectPoliciesResponse] = None
    ListOutgoingTypedLinks: Optional[BatchListOutgoingTypedLinksResponse] = None
    ListPolicyAttachments: Optional[BatchListPolicyAttachmentsResponse] = None
    LookupPolicy: Optional[BatchLookupPolicyResponse] = None


class BatchRemoveFacetFromObject(BaseModel):
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')
    SchemaFacet_1: SchemaFacet = Field(..., alias='SchemaFacet')


class BatchUpdateLinkAttributes(BaseModel):
    AttributeUpdates: LinkAttributeUpdateList
    TypedLinkSpecifier_1: TypedLinkSpecifier = Field(..., alias='TypedLinkSpecifier')


class BatchUpdateObjectAttributes(BaseModel):
    AttributeUpdates: ObjectAttributeUpdateList
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class BatchWriteOperation(BaseModel):
    AddFacetToObject: Optional[BatchAddFacetToObject] = None
    AttachObject: Optional[BatchAttachObject] = None
    AttachPolicy: Optional[BatchAttachPolicy] = None
    AttachToIndex: Optional[BatchAttachToIndex] = None
    AttachTypedLink: Optional[BatchAttachTypedLink] = None
    CreateIndex: Optional[BatchCreateIndex] = None
    CreateObject: Optional[BatchCreateObject] = None
    DeleteObject: Optional[BatchDeleteObject] = None
    DetachFromIndex: Optional[BatchDetachFromIndex] = None
    DetachObject: Optional[BatchDetachObject] = None
    DetachPolicy: Optional[BatchDetachPolicy] = None
    DetachTypedLink: Optional[BatchDetachTypedLink] = None
    RemoveFacetFromObject: Optional[BatchRemoveFacetFromObject] = None
    UpdateLinkAttributes: Optional[BatchUpdateLinkAttributes] = None
    UpdateObjectAttributes: Optional[BatchUpdateObjectAttributes] = None


class BatchWriteOperationList(RootModel[List[BatchWriteOperation]]):
    root: List[BatchWriteOperation]


class BatchWriteOperationResponse(BaseModel):
    AddFacetToObject: Optional[BatchAddFacetToObjectResponse] = None
    AttachObject: Optional[BatchAttachObjectResponse] = None
    AttachPolicy: Optional[BatchAttachPolicyResponse] = None
    AttachToIndex: Optional[BatchAttachToIndexResponse] = None
    AttachTypedLink: Optional[BatchAttachTypedLinkResponse] = None
    CreateIndex: Optional[BatchCreateIndexResponse] = None
    CreateObject: Optional[BatchCreateObjectResponse] = None
    DeleteObject: Optional[BatchDeleteObjectResponse] = None
    DetachFromIndex: Optional[BatchDetachFromIndexResponse] = None
    DetachObject: Optional[BatchDetachObjectResponse] = None
    DetachPolicy: Optional[BatchDetachPolicyResponse] = None
    DetachTypedLink: Optional[BatchDetachTypedLinkResponse] = None
    RemoveFacetFromObject: Optional[BatchRemoveFacetFromObjectResponse] = None
    UpdateLinkAttributes: Optional[BatchUpdateLinkAttributesResponse] = None
    UpdateObjectAttributes: Optional[BatchUpdateObjectAttributesResponse] = None


class BatchWriteOperationResponseList(RootModel[List[BatchWriteOperationResponse]]):
    root: List[BatchWriteOperationResponse]


class BatchWriteRequest(BaseModel):
    Operations: BatchWriteOperationList


class BatchWriteResponse(BaseModel):
    Responses: Optional[BatchWriteOperationResponseList] = None


class CreateIndexRequest(BaseModel):
    IsUnique: Bool
    LinkName_1: Optional[LinkName] = Field(None, alias='LinkName')
    OrderedIndexedAttributeList: AttributeKeyList
    ParentReference: Optional[ObjectReference] = None


class CreateObjectRequest(BaseModel):
    LinkName_1: Optional[LinkName] = Field(None, alias='LinkName')
    ObjectAttributeList: Optional[AttributeKeyAndValueList] = None
    ParentReference: Optional[ObjectReference] = None
    SchemaFacets: SchemaFacetList


class DeleteObjectRequest(BaseModel):
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class DetachFromIndexRequest(BaseModel):
    IndexReference: ObjectReference
    TargetReference: ObjectReference


class DetachObjectRequest(BaseModel):
    LinkName_1: LinkName = Field(..., alias='LinkName')
    ParentReference: ObjectReference


class DetachPolicyRequest(BaseModel):
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')
    PolicyReference: ObjectReference


class DetachTypedLinkRequest(BaseModel):
    TypedLinkSpecifier_1: TypedLinkSpecifier = Field(..., alias='TypedLinkSpecifier')


class GetLinkAttributesRequest(BaseModel):
    AttributeNames: AttributeNameList
    ConsistencyLevel_1: Optional[ConsistencyLevel] = Field(
        None, alias='ConsistencyLevel'
    )
    TypedLinkSpecifier_1: TypedLinkSpecifier = Field(..., alias='TypedLinkSpecifier')


class GetObjectAttributesRequest(BaseModel):
    AttributeNames: AttributeNameList
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')
    SchemaFacet_1: SchemaFacet = Field(..., alias='SchemaFacet')


class GetObjectInformationRequest(BaseModel):
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class ListAttachedIndicesRequest(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    TargetReference: ObjectReference


class ListIncomingTypedLinksRequest(BaseModel):
    ConsistencyLevel_1: Optional[ConsistencyLevel] = Field(
        None, alias='ConsistencyLevel'
    )
    FilterAttributeRanges: Optional[TypedLinkAttributeRangeList] = None
    FilterTypedLink: Optional[TypedLinkSchemaAndFacetName] = None
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class ListIncomingTypedLinksResponse(BaseModel):
    LinkSpecifiers: Optional[TypedLinkSpecifierList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class ListIndexRequest(BaseModel):
    IndexReference: ObjectReference
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    RangesOnIndexedValues: Optional[ObjectAttributeRangeList] = None


class ListObjectAttributesRequest(BaseModel):
    FacetFilter: Optional[SchemaFacet] = None
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class ListObjectChildrenRequest(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class ListObjectParentPathsRequest(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class ListObjectParentsRequest(BaseModel):
    IncludeAllLinksToEachParent: Optional[Bool] = None
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class ListObjectParentsResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ParentLinks: Optional[ObjectIdentifierAndLinkNameList] = None
    Parents: Optional[ObjectIdentifierToLinkNameMap] = None


class ListObjectPoliciesRequest(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class ListOutgoingTypedLinksRequest(BaseModel):
    ConsistencyLevel_1: Optional[ConsistencyLevel] = Field(
        None, alias='ConsistencyLevel'
    )
    FilterAttributeRanges: Optional[TypedLinkAttributeRangeList] = None
    FilterTypedLink: Optional[TypedLinkSchemaAndFacetName] = None
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class ListOutgoingTypedLinksResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    TypedLinkSpecifiers: Optional[TypedLinkSpecifierList] = None


class ListPolicyAttachmentsRequest(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    PolicyReference: ObjectReference


class ListTagsForResourceResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    Tags: Optional[TagList] = None


class LookupPolicyRequest(BaseModel):
    MaxResults: Optional[NumberResults] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    ObjectReference_1: ObjectReference = Field(..., alias='ObjectReference')


class LookupPolicyResponse(BaseModel):
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')
    PolicyToPathList_1: Optional[PolicyToPathList] = Field(
        None, alias='PolicyToPathList'
    )


class Rule(BaseModel):
    Parameters: Optional[RuleParameterMap] = None
    Type: Optional[RuleType] = None


class RuleMap(RootModel[Optional[Dict[str, Rule]]]):
    root: Optional[Dict[str, Rule]] = None


class TypedLinkAttributeDefinition(BaseModel):
    DefaultValue: Optional[TypedAttributeValue] = None
    IsImmutable: Optional[Bool] = None
    Name: AttributeName
    RequiredBehavior: RequiredAttributeBehavior
    Rules: Optional[RuleMap] = None
    Type: FacetAttributeType


class TypedLinkAttributeDefinitionList(RootModel[List[TypedLinkAttributeDefinition]]):
    root: List[TypedLinkAttributeDefinition]


class TypedLinkFacet(BaseModel):
    Attributes: TypedLinkAttributeDefinitionList
    IdentityAttributeOrder: AttributeNameList
    Name: TypedLinkName


class TypedLinkFacetAttributeUpdate(BaseModel):
    Action: UpdateActionType
    Attribute: TypedLinkAttributeDefinition


class TypedLinkFacetAttributeUpdateList(RootModel[List[TypedLinkFacetAttributeUpdate]]):
    root: List[TypedLinkFacetAttributeUpdate]


class UpdateTypedLinkFacetRequest(BaseModel):
    AttributeUpdates: TypedLinkFacetAttributeUpdateList
    IdentityAttributeOrder: AttributeNameList
    Name: TypedLinkName


class Amazonclouddirectory20170111BatchreadXAmzDataPartitionPostRequest(BaseModel):
    Operations: List[BatchReadOperation] = Field(
        ..., description='A list of operations that are part of the batch.'
    )


class Amazonclouddirectory20170111BatchwriteXAmzDataPartitionPutRequest(BaseModel):
    Operations: List[BatchWriteOperation] = Field(
        ..., description='A list of operations that are part of the batch.'
    )


class Amazonclouddirectory20170111TypedlinkFacetXAmzDataPartitionPutRequest(BaseModel):
    AttributeUpdates: List[TypedLinkFacetAttributeUpdate] = Field(
        ..., description='Attributes update structure.'
    )
    IdentityAttributeOrder: List[AttributeName] = Field(
        ...,
        description='The order of identity attributes for the facet, from most significant to least significant. The ability to filter typed links considers the order that the attributes are defined on the typed link facet. When providing ranges to a typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range. Filters are interpreted in the order of the attributes on the typed link facet, not the order in which they are supplied to any API calls. For more information about identity attributes, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.',
    )
    Name: constr(pattern=r'^[a-zA-Z0-9._-]*$') = Field(
        ..., description='The unique name of the typed link facet.'
    )


class Facet1(BaseModel):
    Attributes: Optional[TypedLinkAttributeDefinitionList] = None
    IdentityAttributeOrder: Optional[AttributeNameList] = None
    Name: Optional[TypedLinkName] = None


class Amazonclouddirectory20170111TypedlinkFacetCreateXAmzDataPartitionPutRequest(
    BaseModel
):
    Facet: Facet1 = Field(
        ...,
        description='Defines the typed links structure and its attributes. To create a typed link facet, use the <a>CreateTypedLinkFacet</a> API.',
    )


class BatchReadOperationResponse(BaseModel):
    ExceptionResponse: Optional[BatchReadException] = None
    SuccessfulResponse: Optional[BatchReadSuccessfulResponse] = None


class BatchReadOperationResponseList(RootModel[List[BatchReadOperationResponse]]):
    root: List[BatchReadOperationResponse]


class BatchReadResponse(BaseModel):
    Responses: Optional[BatchReadOperationResponseList] = None


class CreateTypedLinkFacetRequest(BaseModel):
    Facet: TypedLinkFacet


class FacetAttributeDefinition(BaseModel):
    DefaultValue: Optional[TypedAttributeValue] = None
    IsImmutable: Optional[Bool] = None
    Rules: Optional[RuleMap] = None
    Type: FacetAttributeType


class ListTypedLinkFacetAttributesResponse(BaseModel):
    Attributes: Optional[TypedLinkAttributeDefinitionList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class FacetAttribute(BaseModel):
    AttributeDefinition: Optional[FacetAttributeDefinition] = None
    AttributeReference: Optional[FacetAttributeReference] = None
    Name: AttributeName
    RequiredBehavior: Optional[RequiredAttributeBehavior] = None


class FacetAttributeList(RootModel[List[FacetAttribute]]):
    root: List[FacetAttribute]


class FacetAttributeUpdate(BaseModel):
    Action: Optional[UpdateActionType] = None
    Attribute: Optional[FacetAttribute] = None


class FacetAttributeUpdateList(RootModel[List[FacetAttributeUpdate]]):
    root: List[FacetAttributeUpdate]


class ListFacetAttributesResponse(BaseModel):
    Attributes: Optional[FacetAttributeList] = None
    NextToken_1: Optional[NextToken] = Field(None, alias='NextToken')


class UpdateFacetRequest(BaseModel):
    AttributeUpdates: Optional[FacetAttributeUpdateList] = None
    Name: FacetName
    ObjectType_1: Optional[ObjectType] = Field(None, alias='ObjectType')


class Amazonclouddirectory20170111FacetXAmzDataPartitionPutRequest(BaseModel):
    AttributeUpdates: Optional[List[FacetAttributeUpdate]] = Field(
        None,
        description='List of attributes that need to be updated in a given schema <a>Facet</a>. Each attribute is followed by <code>AttributeAction</code>, which specifies the type of update operation to perform. ',
    )
    Name: constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=64) = Field(
        ..., description='The name of the facet.'
    )
    ObjectType_1: Optional[ObjectType] = Field(
        None,
        alias='ObjectType',
        description='The object type that is associated with the facet. See <a>CreateFacetRequest$ObjectType</a> for more details.',
    )


class Amazonclouddirectory20170111FacetCreateXAmzDataPartitionPutRequest(BaseModel):
    Attributes: Optional[List[FacetAttribute]] = Field(
        None, description='The attributes that are associated with the <a>Facet</a>.'
    )
    FacetStyle_1: Optional[FacetStyle] = Field(
        None,
        alias='FacetStyle',
        description='There are two different styles that you can define on any given facet, <code>Static</code> and <code>Dynamic</code>. For static facets, all attributes must be defined in the schema. For dynamic facets, attributes can be defined during data plane operations.',
    )
    Name: constr(pattern=r'^[a-zA-Z0-9._-]*$', min_length=1, max_length=64) = Field(
        ...,
        description='The name of the <a>Facet</a>, which is unique for a given schema.',
    )
    ObjectType_1: Optional[ObjectType] = Field(
        None,
        alias='ObjectType',
        description='<p>Specifies whether a given object created from this facet is of type node, leaf node, policy or index.</p> <ul> <li> <p>Node: Can have multiple children but one parent.</p> </li> </ul> <ul> <li> <p>Leaf node: Cannot have children but can have multiple parents.</p> </li> </ul> <ul> <li> <p>Policy: Allows you to store a policy document and policy type. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies">Policies</a>.</p> </li> </ul> <ul> <li> <p>Index: Can be created with the Index API.</p> </li> </ul>',
    )


class CreateFacetRequest(BaseModel):
    Attributes: Optional[FacetAttributeList] = None
    FacetStyle_1: Optional[FacetStyle] = Field(None, alias='FacetStyle')
    Name: FacetName
    ObjectType_1: Optional[ObjectType] = Field(None, alias='ObjectType')
